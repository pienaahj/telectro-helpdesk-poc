[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "HD Ticket",
  "enabled": 1,
  "modified": "2026-02-05 14:55:29.143309",
  "module": null,
  "name": "Claim HD Ticket",
  "script": "function parseAssignees(val) {\n  // Returns an array of emails/usernames\n  if (val === null || val === undefined || val === \"\" || val === \"[]\") return [];\n\n  if (Array.isArray(val)) return val;\n\n  if (typeof val === \"string\") {\n    try {\n      const parsed = JSON.parse(val);\n      if (Array.isArray(parsed)) return parsed;\n    } catch (e) {}\n    // if it's some other string, treat it as a single value\n    return [val];\n  }\n\n  return [String(val)];\n}\n\nfunction prettyAssignee(val) {\n  const a = parseAssignees(val);\n  if (!a.length) return \"unknown\";\n  return a.join(\", \");\n}\n\nfunction firstAssignee(val) {\n  const a = parseAssignees(val);\n  return a.length ? a[0] : null;\n}\n\nconst POOL_USER = \"helpdesk@local.test\";\n\nasync function getAssignValueFresh(ticketName) {\n  // Preferred: frappe.db.get_value\n  if (frappe.db && frappe.db.get_value) {\n    const r = await frappe.db.get_value(\"HD Ticket\", ticketName, \"_assign\");\n    return (r && r.message && r.message._assign) || \"\";\n  }\n\n  // Fallback\n  const r = await frappe.call({\n    method: \"frappe.client.get_value\",\n    args: {\n      doctype: \"HD Ticket\",\n      filters: { name: ticketName },\n      fieldname: [\"_assign\"],\n    },\n  });\n  return (r && r.message && r.message._assign) || \"\";\n}\n\nfunction addClaimButton(frm) {\n  frm.add_custom_button(\n    __(\"Claim\"),\n    () => {\n      frappe.call({\n        method: \"telephony.telectro_claim.telectro_claim_ticket\",\n        type: \"POST\",\n        args: { ticket: frm.doc.name },\n        freeze: true,\n        callback: (r) => {\n          const m = r.message || {};\n\n          // ✅ Success path\n          if (m.ok) {\n            frappe.show_alert({ message: __(\"Claimed\"), indicator: \"green\" });\n            frm.reload_doc();\n            return;\n          }\n\n          // ✅ Race/stale UI path: server replied \"already_claimed\" but assignee is the pool user\n          const assigned = parseAssignees(m.assigned_to);\n          const isPool = assigned.length === 1 && assigned[0] === POOL_USER;\n\n          if (m.reason === \"already_claimed\" && isPool) {\n            frappe.show_alert({\n              message: __(\"Claim in progress… refreshing\"),\n              indicator: \"orange\",\n            });\n            frm.reload_doc();\n            return;\n          }\n\n          // Normal \"already claimed by another tech\" path\n          if (m.reason === \"already_claimed\") {\n            frappe.msgprint(\n              __(\"Already claimed: {0}\", [prettyAssignee(m.assigned_to)])\n            );\n          } else {\n            frappe.msgprint(__(\"Could not claim ticket.\"));\n          }\n\n          frm.reload_doc();\n        },\n      });\n    },\n    __(\"Actions\")\n  );\n}\n\nfunction addHandoffButton(frm) {\n  frm.add_custom_button(\n    __(\"Handoff\"),\n    () => {\n      frappe.prompt(\n        [\n          {\n              fieldname: \"to_user\",\n              fieldtype: \"Link\",\n              options: \"User\",\n              label: __(\"Handoff to\"),\n              reqd: 1,\n              get_query: () => ({\n                filters: {\n                  enabled: 1,\n                  // optional: keep it tight; comment out if it blocks valid techs\n                  // user_type: \"System User\",\n                },\n              }),\n            },\n\n          {\n            fieldname: \"reason\",\n            fieldtype: \"Small Text\",\n            label: __(\"Reason\"),\n            reqd: 1, // friction: required\n          },\n        ],\n        (values) => {\n          const to_user = (values.to_user || \"\").trim();\n          const reason = (values.reason || \"\").trim();\n\n          frappe.call({\n            method: \"telephony.telectro_claim.telectro_handoff_ticket\",\n            type: \"POST\",\n            args: { ticket: frm.doc.name, to_user, reason },\n            freeze: true,\n            callback: (r) => {\n              const m = r.message || {};\n\n              if (m.ok) {\n                frappe.show_alert({\n                  message: __(\"Handed off to {0}\", [m.to || to_user]),\n                  indicator: \"green\",\n                });\n                frm.reload_doc();\n                return;\n              }\n\n              if (m.reason === \"not_owner\") {\n                frappe.msgprint(__(\"Only the current assignee may handoff this ticket.\"));\n                frm.reload_doc();\n                return;\n              }\n\n              if (m.reason === \"already_assigned\") {\n                frappe.msgprint(\n                  __(\"Already assigned: {0}\", [prettyAssignee(m.assigned_to)])\n                );\n                frm.reload_doc();\n                return;\n              }\n\n              if (m.reason === \"invalid_user\") {\n                frappe.msgprint(__(\"Invalid user: {0}\", [m.to_user || to_user]));\n                return;\n              }\n\n              frappe.msgprint(__(\"Could not handoff ticket.\"));\n              frm.reload_doc();\n            },\n          });\n        },\n        __(\"Handoff Ticket\"),\n        __(\"Handoff\")\n      );\n    },\n    __(\"Actions\")\n  );\n}\n\n// ✅ NEW: Release back to pool (handoff to POOL_USER) with required reason\nfunction addReleaseToPoolButton(frm) {\n  frm.add_custom_button(\n    __(\"Release to Pool\"),\n    () => {\n      frappe.prompt(\n        [\n          {\n            fieldname: \"reason\",\n            fieldtype: \"Small Text\",\n            label: __(\"Reason\"),\n            reqd: 1, // friction: required\n          },\n        ],\n        (values) => {\n          const reason = (values.reason || \"\").trim();\n\n          frappe.call({\n            method: \"telephony.telectro_claim.telectro_handoff_ticket\",\n            type: \"POST\",\n            args: { ticket: frm.doc.name, to_user: POOL_USER, reason },\n            freeze: true,\n            callback: (r) => {\n              const m = r.message || {};\n\n              if (m.ok) {\n                frappe.show_alert({\n                  message: __(\"Released to pool\"),\n                  indicator: \"green\",\n                });\n                frm.reload_doc();\n                return;\n              }\n\n              if (m.reason === \"not_owner\") {\n                frappe.msgprint(__(\"Only the current assignee may release this ticket.\"));\n                frm.reload_doc();\n                return;\n              }\n\n              frappe.msgprint(__(\"Could not release ticket.\"));\n              frm.reload_doc();\n            },\n          });\n        },\n        __(\"Release Ticket\"),\n        __(\"Release\")\n      );\n    },\n    __(\"Actions\")\n  );\n}\n\nfrappe.ui.form.on(\"HD Ticket\", {\n  async refresh(frm) {\n    if (!frm.doc || !frm.doc.name) return;\n\n    // Important: Helpdesk form does not include _assign in frm.doc, so fetch it.\n    let assignVal = \"\";\n    try {\n      assignVal = await getAssignValueFresh(frm.doc.name);\n    } catch (e) {\n      return; // fail closed: avoid showing wrong buttons\n    }\n\n    const assignees = parseAssignees(assignVal);\n\n    const is_unassigned = assignees.length === 0;\n    const is_pool_owned = assignees.length === 1 && assignees[0] === POOL_USER;\n\n    const claimable = is_unassigned || is_pool_owned;\n\n    const owner = firstAssignee(assignVal);\n    const is_owned_by_me = owner && owner === frappe.session.user;\n\n    // Add buttons only when appropriate\n    if (claimable) addClaimButton(frm);\n\n    if (is_owned_by_me) {\n      addHandoffButton(frm);\n      addReleaseToPoolButton(frm); // ✅ NEW\n    }\n  },\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "HD Ticket",
  "enabled": 1,
  "modified": "2026-01-30 09:45:17.201780",
  "module": null,
  "name": "Pull Faults",
  "script": "// HD Ticket (List) — auto-refresh ONLY when viewing Faults\n(function () {\n  var TIMER_KEY = \"__hd_faults_autorefresh_timer\";\n  var HANDLER_KEY = \"__hd_faults_listupdate_handler\";\n  var TICK_N = 0;\n  \n  // Somewhere near PullFaults init scope:\n    var rtHits = 0;\n    \n    // When attaching realtime:\n    if (socket && socket.on) {\n      console.log(\"[PullFaults] binding realtime list_update handler; socket.on exists=\", true);\n    \n      socket.on(\"list_update\", function (data) {\n        rtHits += 1;\n        console.log(\"[PullFaults] REALTIME HIT #\" + rtHits, \"data=\", data);\n    \n        // Optional: if you want realtime to trigger refresh when in Faults view\n        // (only do this if it doesn't spam)\n        if (faultsView) {\n          // call your internal refresh function here if you have one\n          // e.g. refreshNow(\"realtime\");\n        }\n      });\n    \n      console.log(\"[PullFaults] realtime handler attached\");\n    }\n\n\n  var DEBUG = true;\n  function dbg() {\n    if (DEBUG && window.console) {\n      console.log.apply(console, [\"[PullFaults]\"].concat([].slice.call(arguments)));\n    }\n  }\n\n  function getFilters(listview) {\n    try {\n      if (listview && listview.filter_area && listview.filter_area.get) {\n        return listview.filter_area.get() || [];\n      }\n      return [];\n    } catch (e) {\n      return [];\n    }\n  }\n\n  function toLowerStr(v) {\n    if (v === null || v === undefined) return \"\";\n    return String(v).toLowerCase();\n  }\n\n  function matchFaultsFilter(fieldname, opRaw, valRaw) {\n    var op = toLowerStr(opRaw);\n    var val = toLowerStr(valRaw);\n\n    // exactly the Faults Console filter\n    if (fieldname !== \"custom_service_area\") return false;\n    if (op !== \"=\") return false;\n    return val === \"faults\";\n  }\n\n  function isFaultsView(listview) {\n    var filters = getFilters(listview);\n    // filters often look like: [doctype, fieldname, operator, value, hidden?]\n    for (var i = 0; i < filters.length; i++) {\n      var f = filters[i];\n      if (!f || f.length < 4) continue;\n\n      // f[0] doctype; f[1] fieldname; f[2] operator; f[3] value\n      if (f[0] === \"HD Ticket\" && matchFaultsFilter(f[1], f[2], f[3])) return true;\n    }\n    return false;\n  }\n\n  function debounce(fn, ms) {\n    var t = null;\n    return function () {\n      var args = arguments;\n      clearTimeout(t);\n      t = setTimeout(function () {\n        try {\n          fn.apply(null, args);\n        } catch (e) {}\n      }, ms);\n    };\n  }\n\n  function clearTimer() {\n    if (window[TIMER_KEY]) {\n      clearInterval(window[TIMER_KEY]);\n      window[TIMER_KEY] = null;\n    }\n  }\n\n  function clearRealtimeHandler() {\n    var h = window[HANDLER_KEY];\n    if (!h) return;\n\n    try {\n      if (window.frappe && frappe.realtime && frappe.realtime.socket && frappe.realtime.socket.off) {\n        frappe.realtime.socket.off(\"list_update\", h);\n      }\n    } catch (e) {}\n    window[HANDLER_KEY] = null;\n  }\n\n  // ✅ Important: only call this when listview exists (inside start/onload)\n  function postLoadCheck(listview) {\n    setTimeout(function () {\n      try {\n        dbg(\"post-load check; faultsView=\", isFaultsView(listview), \"filters=\", getFilters(listview));\n      } catch (e) {}\n    }, 1500);\n  }\n\n  function start(listview) {\n    clearTimer();\n    clearRealtimeHandler();\n\n    TICK_N = 0;\n\n    var safeRefresh = debounce(function () {\n      try {\n        if (isFaultsView(listview)) {\n          listview.refresh();\n        }\n      } catch (e) {}\n    }, 1000);\n\n    dbg(\"start() called; faultsView=\", isFaultsView(listview), \"filters=\", getFilters(listview));\n\n    // ✅ runs after listview exists (fixes \"listview is not defined\")\n    postLoadCheck(listview);\n\n    // Light poll: only refresh when Faults filter is active\n    window[TIMER_KEY] = setInterval(function () {\n      TICK_N += 1;\n      if (!isFaultsView(listview)) return;\n      safeRefresh();\n      dbg(\"tick#\", TICK_N, \"faultsView=true\");\n    }, 15000);\n\n    // Realtime: refresh quickly when tickets update (still scoped to Faults view)\n    try {\n      if (window.frappe && frappe.realtime && frappe.realtime.socket && frappe.realtime.socket.on) {\n        dbg(\"binding realtime list_update handler; socket.on exists=\", true);\n    \n        var handler = function (data) {\n          dbg(\"realtime list_update raw=\", data);\n          if (!data || data.doctype !== \"HD Ticket\") return;\n          dbg(\"realtime list_update (HD Ticket) name=\", data.name);\n          safeRefresh();\n        };\n    \n        window[HANDLER_KEY] = handler;\n        frappe.realtime.socket.on(\"list_update\", handler);\n    \n        dbg(\"realtime handler attached\");\n      } else {\n        dbg(\"realtime not available; no handler bound\");\n      }\n    } catch (e) {\n      dbg(\"realtime bind error\", e);\n    }\n\n\n    // Cleanup when leaving the list page\n    try {\n      if (listview && listview.page && listview.page.on) {\n        listview.page.on(\"hide\", function () {\n          clearTimer();\n          clearRealtimeHandler();\n        });\n      }\n    } catch (e) {}\n  }\n\n  // Hook listview onload safely (preserve prior onload)\n  frappe.listview_settings[\"HD Ticket\"] = frappe.listview_settings[\"HD Ticket\"] || {};\n  var prevOnload = frappe.listview_settings[\"HD Ticket\"].onload;\n\n  frappe.listview_settings[\"HD Ticket\"].onload = function (listview) {\n    try {\n      if (prevOnload) prevOnload(listview);\n    } catch (e) {}\n    start(listview);\n  };\n})();\n",
  "view": "List"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "HD Ticket",
  "enabled": 1,
  "modified": "2026-02-13 09:03:27.547126",
  "module": null,
  "name": "Clear Customer and filter List",
  "script": "frappe.ui.form.on(\"HD Ticket\", {\n  refresh(frm) {\n    // Only show pilot locations (children of \"Pilot Sites\")\n    frm.set_query(\"custom_site\", () => ({\n      filters: {\n        parent_location: \"Pilot Sites\",\n      },\n    }));\n  },\n\n  custom_customer(frm) {\n    // Keep it simple: customer change invalidates existing site choice\n    if (frm.doc.custom_site) {\n      frm.set_value(\"custom_site\", null);\n    }\n  },\n});\n",
  "view": "Form"
 }
]